# Industry track

## Dead Streaming

## About the project
Dead Streaming is a distributed live streaming app that allows people to stream their screen live to viewers, who can select a stream to watch from the list of currently active ones.
## Implemented components:
### Broadcaster
A broadcaster can access the app's website and go to the /live route, where they can select a stream title and begin streaming. The title and stream id, which is used to create a link to the stream, will be recorded by the main server. Video of the stream (really just a screen share at this point in time) will be continuously recorded and sent to the CDN every 5 seconds.

### Viewer
Viewers can access the same website as the broadcasters, but go to the /view route, where a list of currently active streams are visible, and can click on one to view a stream, though there is a 5 second delay before a chunk is received and the playback can start. Chunks are thereafter retrieved every 5 seconds for a continuous viewing experience.

### CDN(s)
One or more CDNs are used to distribute stream footage from broadcasters to viewers. The app can use multiple CDNs to implement load balancing. Each CDN has an upload_chunk and download_chunk route, which are used by the broadcaster and viewer respectively to send and receive chunks of video. There is a mechanism for CDNs to register themselves to the main server so that a list of CDNs does not need to be hardcoded. 

### Main server
The main server manages the other nodes and keeps track of app-wide tasks. For instance, CDNs that come online register themselves with the main server. Also, the main server keeps a list of active streams, to show the viewer at the /view route, and deletes completed streams from said list. Finally, the load balancing logic is done on the main server. Utilization is tracked by counting the broadcasters that are streaming to a particular CDN, and each chunk is uploaded to the CDN with the lowest utilization (exception: if the CDN a particular stream is already streaming to is only one higher than the utilization, it will keep streaming to that CDN to avoid unnecessary churn). 

### Distributed Systems principles
#### Architecture
A diagram of the system architecture can be seen below.

#### Naming
Unique streamids are generated by taking a hex digest of the MD5 hash of the stream title concatenated with the system time at the time the stream was created. This ensures that each stream has a unique name and can thus be accessed by a specific URL. [Do we need to talk about CDN naming?Â¨]

#### Communication 
Communication between nodes is primarily done by means of HTTP GET and POST requests. Video is transferred in the form of Blobs. 

## Built with:
### Frontend
Vanilla JavaScript was used for the frontend. The MediaRecorder and MediaSource APIs proved useful in recording and playing back video.
### Backend 
The backend, including the API routes and load balancing logic, were done in Python, using the Flask framework.

## Results of the tests:
Detailed description of the system evaluation
Evaluate your implementation using selected criteria, for example:
- Number of messages / lost messages, latencies, ...
- Request processing with different payloads, ..
- System throughput, ..


Design two evaluation scenarios that you compare with each other, for example:
- Small number / large number of messages
- Small payload / big payload

Collect numerical data of test cases:
- Collecting logs of container operations
- Conduct simple analysis for documentation purposes (e.g. plots or graphs)


